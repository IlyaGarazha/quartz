# Занятие_3

1. Отсортируйте стандартным алгоритмом `std::sort` вектор строк: 
```
ccc
bb
a
dddd
```
В каком порядке сортируются эти строчки?

	1. Напишите функтор, который будет их сортировать в порядке убывания их длины.
	2. Напишите лямбда-функцию, которая делает то же самое.2. 
2.

1. Напишите лямбда-функцию, которая создаёт вектор из `n > 10` случайных int-элементов от 1 до 9'999. 
	
2. Напишите лямбда-функцию, которая из вектора, полученного в предыдущем пункте, возвращает вектор элементов, чьи первые цифры встречаются чаще всего.
   
   11, 22, 33, 44, 55, 66, 77, 88, 99,  12,  13 ==> 11, 12, 13

### Подсказки ко второму заданию:
Захват контекста по ссылке:
```cpp
  int count = 0;  // счётчик, сколько раз запустили
  auto comp = [&count](int a, int b) {  // count захвачен по ссылке
    ++count;
    return a < b;
  };
  std::set<int, decltype(comp)> s({1, 3, 2, 4, 5, 6}, comp);
  std::cout
      << count;  // => 8 (столько раз понадобился компаратор для КЧ дерева)

```
Вектор из рандомных чисел от 1 до 9'999
```cpp
#include <algorithm>
#include <iostream>
#include <random>
#include <vector>

using namespace std;
int main() {
  random_device rnd_device;
  mt19937 mersenne_engine{rnd_device()};
  uniform_int_distribution<int> dist{1, 9'999};

  auto gen = [&dist, &mersenne_engine]() { return dist(mersenne_engine); };
  vector<int> vec(15);
  generate(begin(vec), end(vec), gen);
  
  for (auto i : vec) {
	  cout << i << " ";
  }
}
```
Найти наиболее частую первую цифру можно с помощью map или unordered map.  (`Ключ`, `значение`) => (`Цифра`, `частота вхождения`)

Для поиска наибольшего элемента словаря можно воспользоваться max_element
Важно учитывать, в каком порядке (a < b) или (b < a) вы сравниваете элементы:
```cpp
template<class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp)
{
    if (first == last)
        return last;
 
    ForwardIt largest = first;
 
    while(++first != last)
        if (comp(*largest, *first))
            largest = first;
 
    return largest;
}
```
Не забудьте, что вы сравниваете пары (std::pair) словаря.  (по значению, а не по ключу).  А также, про разыменование итератора `it->member`.

Необязательно использовать for_each, в векторах можно итерироваться через индексы, а не итераторы.

# Занятие_2

(На семинаре)
Внутри одного файла построчно реализуйте класс Car и Detail, притом, что 
1. класс Detail объявлен внутри Car.
2. Внутри Car есть только член std::unordered_map<int, Detail> price_list;
3. Внутри Detail член только std::string name; 

В чём ошибка?

Посмотреть, как работает функция swap на примере `std::pair` в `#include <utility>`

(В качестве дз)
Реализовать интерфейс (`graph.h`) к ЛР2



# Занятие_1

1. Склонируйте ваш репозиторий.
2. Удалите все папки и файлы, кроме скрытой папки `.git` и README.md
3. Создайте 16 папок с названием sem_1 ... sem_16 и добавьте в каждую по (пустому, например) файлу CMakeLists.txt
4. С помощью `git add`, `git commit` и `git push` сохраните эти изменения.
5. Используя  `git checkout` переместитесь между коммитами github-репозитория. Для того чтобы удобно перемещаться по коммитам в консоли можете использовать `git checkout +TAB` (+TAB - нажатие клавиши). (Должны быть прописаны git checkout 37425). У каждого коммита своя последовательность цифр. Посмотрите, как поменялась директория и её содержимое. 
6. Внесите небольшое изменение в любой из файлов (например, README.md) .
7. Перейдите обратно в main: `git checkout main`.
8. С помощью `git add`, `git commit` сохраните эти изменения.
10. Посмотрите на состояние директории и откройте файлы README.md
11. Теперь можно запушить коммит.


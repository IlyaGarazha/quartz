# Занятие 6
1. Создайте публичный (или приватный, но предоставив доступ для проверки) репозиторий Seminar_6.
   Добавьте в этот проект [[Submodules|подмодули]] Matrix и Graph. (С согласия студентов, вы можете использовать проекты ваших коллег.) (*2 балла*)
2. Создайте ориентированный граф, используя матрицу смежности, созданную с использованием Matrix (*2 балла*).
3. [[Визуализация графа|Визуализируйте]] этот граф, используя расширение для VS Code GraphViz (*4 балла*).
# Занятие 5


1. Объяснить последовательность вызовов конструкторов и деструкторов (3 балла).
```cpp
#include <iostream>
#include <memory>
using namespace std;

struct Logger {
  Logger() { cout << "Default ctor\n"; }
  Logger(const Logger&) { cout << "Copy ctor\n"; }
  Logger(Logger&&) { cout << "Move ctor\n"; }
  ~Logger() { cout << "Dtor\n"; }
};

unique_ptr<Logger> LoggerUPtrFunc(const Logger& lgr) {
  cout << "Inside Function\n";
  unique_ptr<Logger> uptr(new Logger);
  throw(runtime_error("Logger error!"));
  return uptr;
}

int main() {
  Logger lgr;
  unique_ptr<Logger> uptr(new Logger);
  try {
    uptr = LoggerUPtrFunc(lgr);
  } catch (...) {
    cout << "Catching\n";
  }
}

```
2. Какие моменты не были учтены в реализации shared_ptr текущего занятия? (3 балла)
   За каждый пункт - 1 балл.
3.  Распишите подробно логику примера с weak_ptr

# Занятие_3

1. Отсортируйте стандартным алгоритмом `std::sort` вектор строк ***(1 балл)***: 
```
ccc
bb
a
dddd
```
В каком порядке сортируются эти строчки?

- Напишите функтор, который будет их сортировать в порядке убывания их длины. ***(1 балл)***
-  Напишите лямбда-функцию, которая делает то же самое.2. ***(2 балла)***
2.

1. Напишите лямбда-функцию, которая создаёт вектор из `n > 10` случайных int-элементов от 1 до 9'999. 
	
2. Напишите лямбда-функцию, которая из вектора, полученного в предыдущем пункте, возвращает вектор элементов, чьи первые цифры встречаются чаще всего.
   
   11, 22, 33, 44, 55, 66, 77, 88, 99,  12,  13 ==> 11, 12, 13

### Подсказки ко второму заданию:
Захват контекста по ссылке:
```cpp
  int count = 0;  // счётчик, сколько раз запустили
  auto comp = [&count](int a, int b) {  // count захвачен по ссылке
    ++count;
    return a < b;
  };
  std::set<int, decltype(comp)> s({1, 3, 2, 4, 5, 6}, comp);
  std::cout
      << count;  // => 8 (столько раз понадобился компаратор для КЧ дерева)

```
Вектор из рандомных чисел от 1 до 9'999
```cpp
#include <algorithm>
#include <iostream>
#include <random>
#include <vector>

using namespace std;
int main() {
  random_device rnd_device;
  mt19937 mersenne_engine{rnd_device()};
  uniform_int_distribution<int> dist{1, 9'999};

  auto gen = [&dist, &mersenne_engine]() { return dist(mersenne_engine); };
  vector<int> vec(15);
  generate(begin(vec), end(vec), gen);
  
  for (auto i : vec) {
	  cout << i << " ";
  }
}
```
Найти наиболее частую первую цифру можно с помощью map или unordered map.
***(2 балла)***


(`Ключ`, `значение`) => (`Цифра`, `частота вхождения`)

Для поиска наибольшего элемента словаря можно воспользоваться max_element
***(1 балл)***


Важно учитывать, в каком порядке (a < b) или (b < a) вы сравниваете элементы:
```cpp
template<class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp)
{
    if (first == last)
        return last;
 
    ForwardIt largest = first;
 
    while(++first != last)
        if (comp(*largest, *first))
            largest = first;
 
    return largest;
}
```
Не забудьте, что вы сравниваете пары (std::pair) словаря.  (по значению, а не по ключу).  А также, про разыменование итератора `it->member`.

Необязательно использовать for_each, в векторах можно итерироваться через индексы, а не итераторы.


Выполненное задание до конца - ***(1 балл)***

# Занятие_2

(На семинаре)
Внутри одного файла построчно реализуйте класс Car и Detail, притом, что 
1. класс Detail объявлен внутри Car.
2. Внутри Car есть только член std::unordered_map<int, Detail> price_list;
3. Внутри Detail член только std::string name; 

В чём ошибка?

Посмотреть, как работает функция swap на примере `std::pair` в `#include <utility>`

(В качестве дз)
Реализовать интерфейс (`graph.h`) к ЛР2



# Занятие_1

1. Склонируйте ваш репозиторий.
2. Удалите все папки и файлы, кроме скрытой папки `.git` и README.md
3. Создайте 16 папок с названием sem_1 ... sem_16 и добавьте в каждую по (пустому, например) файлу CMakeLists.txt
4. С помощью `git add`, `git commit` и `git push` сохраните эти изменения.
5. Используя  `git checkout` переместитесь между коммитами github-репозитория. Для того чтобы удобно перемещаться по коммитам в консоли можете использовать `git checkout +TAB` (+TAB - нажатие клавиши). (Должны быть прописаны git checkout 37425). У каждого коммита своя последовательность цифр. Посмотрите, как поменялась директория и её содержимое. 
6. Внесите небольшое изменение в любой из файлов (например, README.md) .
7. Перейдите обратно в main: `git checkout main`.
8. С помощью `git add`, `git commit` сохраните эти изменения.
10. Посмотрите на состояние директории и откройте файлы README.md
11. Теперь можно запушить коммит.


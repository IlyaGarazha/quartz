## Семинар 11

Реализовать классы строительных материалов: проволоки (Wire), шифера (Slate) и кирпича(Brick), которые наследуется от двух классов:
1. Класса формы Shape (прямая/плоская/объёмная).
   Объёмная фигура (VolumetricFigure) наследуется от плоской (PlaneShape), добавляя параметр height. Плоская наследуется от прямой (Line), добавляя к параметру length параметр width.
   Line -> PlaneShape -> VolumetricFigure.
   (прямоугольник (PlaneShape) формируется "вытягиванием" прямой, а параллелепипед - выдавливанием прямоугольника на высоту.)
1. Класс материала Material содержит `char` поле цвета и `double` поле плотности.
В каждом классе строительного материала есть `double` поле массы.
Создать 3 экземпляра материала, 3 экземпляра формы, и на их основе  3 экземпляра строительных материалов.
Вывести массу каждого из экземпляров.
Проволока подразумевается линейной, шифер - плоским, кирпич - объёмным. Считается, что для материала задаётся подходящая по размерности плотность.

*Баллы*:
- 0.5 балла - выполнить пункты для [[GitHub|отправки семинаров]].
- 6 баллов - основное задание. 
- 1 балл - разбить всё на файлы `main.cpp sem11.cpp sem11.h` и использовать [[CMake]]
- 0.5 балла - реалистичность размеров и материалов

Срок - 22.11.2023 23:59. После - 0 за семинар.

(Пример того, как "куб" наследуется из "квадрата" в реальных ПО)
![[cube_from_plane.gif]]
## Семинар 10
1. Выполнить пункты для [[Отправка семинаров|отправки семинаров]]
2. Исследовать взаимодействие дружественных функций при наследовании.
## Семинар 8
### Задание 1
Создайте класс счётчика времени TimeCounter, который будет выводить время выполнения кода, ограниченного областью видимости:
```cpp
void foo();
int main() {
	{
		TimeCounter tc_1("В main'e");
		foo()
		std::cout << tc_1 << std::endl;
		/* Остальной код */ 
	}
}
void foo() {
	{
		TimeCounter tc_2("Внутри foo");
	}
}
```
Вывод в консоль :
```
Внутри foo - 100 ms
В main'e   - 5   ms
```
Перегрузите оператор побитового сдвига << для вывода текущего значения времени:
```
С момента вызова ${m_comment} прошло x ms.
```
### Задание 2
Создайте класс умного указателя SharedPointer на тип int , который позволяет разработчику работать с динамической памятью без необходимости использовать ключевого слова delete.
```
int main() {
SharedPointer sp_1 = new int(7);
{
	SharedPointer sp_2 = sp_1;
}
cout << *sp_1;
}
```
Сразу несколько объектов SharedPointer могут указывать на одну и ту же ячейку памяти. Также необходимо перегрузить оператор разыменования  `*`. 
При определении указателя без явной инициализации по умолчанию он инициализируется значением `nullptr`
## Семинар 6

Сравнить время выполнения 100 000 вызовов конструкций if и switch.
Для этого:
1. Создать перечисление из 6 элементов:
```cpp
enum menu_options
{
    NEW  = 'n',
    OPEN = 'o',
    SAVE = 's',
    COPY = 'c',
    EXIT = 'q',
    DEL  = 'd'
};
```

2. Для каждого поля перечисления menu_options создать соответствующую пустую функцию, которая будет вызываться при вводе пользователем соответствующего ключа `char key`.
3.  Смоделировать случай, когда пользователь всегда выбирает последний вариант (DEL) конструкции if else if ... .
```cpp
#include <iostream>
#include <chrono>
using namespace std;
auto start = chrono::system_clock::now();
// Код
auto end = chrono::system_clock::now();
cout << chrono::duration_cast<chrono::milliseconds>(end - start).count();
```
4. Если пользователь ввёл неверное значение, то выбросить исключение.
5. Как влияет присутствие обработки исключений на время выполнение работы программы? Проиллюстрируйте время с обработкой исключений и без.

## Задание на Git
План:
1. Создать свой проект (любой) на гитлабе
2. Склонировать его (git clone)
3. git add
4. git commit -m "комментарий к коммиту"
5. git push
Как посмотреть состояние файлов:
git status
Как посмотреть состояние коммитов:
git log  --all --graph

Как переключиться на предыдущий коммит:
git checkout
Как зафиксировать то, что не хочу показывать:
git stash

Необходимо отправить на свой репозиторий как минимум 3 коммита. 
## Семинар 5

Указать и объяснить в какой строчке ошибка.

```cpp
int a = 3;	
int& ref = a;
const int& ref2 = ref;
int& ref3 = ref;
int& ref4 = ref2;
```

Проверить в каком порядке вызываются конструкторы класса, если один объект вызывается в глобальном пространстве имён, второй в пользовательском пространстве имён, а третий - в функции main.

Проверить эту таблицу, выполнив все операции и оставив комментарии ошибки:
![[Pasted image 20230930110005.png]]

## Семинар 4
Создать класс "Геометрическая фигура". Членами класса являются поля
1. тип фигуры {прямолинейная ('s'),  кривая('c')}       (**char**)
2. порядок пространства фигуры (0, 1, 2, 3)               (**int**)
3. параметры: (длина, ширина, высота)                      (**double**)
4. мера фигуры (длина, площадь, объём)                   (**double**)
print_type
6. оператор сложения одинаковых мер                      (**double**)

Варианты фигур:
0. точка
1. прямая
2. плоские
	1. квадрат, прямоугольник
	2. круг, эллипс
3. объёмные:
	1. куб, параллелепипед с квадратом в основании, параллелепипед
	2. шар,  эллипсоид с двумя равными полуосями, эллипсоид
```cpp
Shape p; // точка
Shape l(3) //прямая длины 3
Shape r('s', 2, 2) // квадрат площадью 4
Shape e('c', 2, 1, 2)  // эллипс с осями 1, 2
Shape b('c', 3, 5)  // шар радиуса 5

#include <math.h>
#include <cnath>
double x = M_PI;
```
Если складываем объекты разных размерностей, то необходимо вернуть -1, но при этом вывести в cout сообщение об ошибке.
При перегрузке оператора сложения возвращаем объект, у которого все поля 0, кроме значения меры, равного сумме мер.
Поля:
1. кривизна
2. размерность
3. Д/В/Ш
4. Мера
5. Конструкторы
6. Оператор сложения

Баллы:
Перегрузка оператора +  (*4 балла*)
3 перегруженных конструктора  (*2 балла*)
Каждый конструктор более высокого порядка (*2 балла* за каждый)

## Семинар 3

Пользователь вводит следующие данные:
Размер шахматной доски $n$, массив размера $m<n$, которым необходимо заполнить один из углов. (Т.е. входные данные: размер доски, размер массива, сам массив, номер угла)
1. Создать двумерный динамический массив размера $n\times n$ , заполненный 0 и 1 в шахматном порядке. Вывести его на экран перед вводом размера массива.
2. Получить от пользователя размер массива, выделить память под одномерный динамический массив и заполнить его данными от пользователя.
3. Получить от пользователя номер угла, в который поместим квадрат $m\times m$ . 
   1 - левый верхний, дальше по часовой.
4. Заполнить угол доски необходимыми данными.
5. Вывести транспонированный вид доски.
Требования:
- Работать внутри void Chess(), вызываемой из main;
- Если пользователь вводит массив с двузначными или более значениями, то необходимо изменить вывод, чтобы доска оставалась квадратной.
- Не забывать удалять память.
## Семинар 2
### Задача 1
Создать массив из 60 целых чисел от 1 до 60.
Создать функцию PrintTable, которая  выводит эти  числа в виде таблицы $m \times n$, где  $m \in \{1,2,3,4,5,6,10,12,15,20,30\}$ и к последнему столбцу добавляет значение суммы строчки. Последний столбец отделён от предпоследнего знаком `|`. Обращаться к элементам таблицы нужно по ссылке.
## Семинар 1
### Задание 1
Определить значение 3 бита unsigned int-числа 89, используя побитовые операторы.

| 1   | 0   | 1   | 0   | 1   | 1   | 0   |
| --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 1   | 0   | 0   |

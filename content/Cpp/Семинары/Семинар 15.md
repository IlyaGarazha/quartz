# Deducing (вывод типа шаблона)

```cpp
template<typename Т>
void f (ParamType param);

f(expr) // вызов f с некоторым expr
```
В процессе компиляции компилятор использует `expr` для вывода двух типов: типа `Т` и типа `ParamType`. 

Эти типы зачастую различны, поскольку `ParamType` часто содержит "украшения", например `const` или квалификаторы ссылки (`&` или `&&`).

```cpp
template<typename T>
void f(const T& param); // ParamType - const T&
int x = 0;
f(x);  // вызов f с параметром int
```

`Т` выводится как `int`, а `ParamType` - как `const int&`.

Вполне естественно ожидать, что тип, выведенный для Т, тот же, что и тип переданного функции аргумента, т.е. что Т - это тип выражения expr. В приведенном выше примере это так: х - значение типа int и Т выводится как int. Но вывод не всегда работает таким образом.

> [!note]- Тип, выведенный для T, зависит не только от типа expr, но и от вида ParamType. 
> 
> ```cpp
> 	template<typename Т>
> 	void f (ParamType param);
> 	f(expr) // вызов f с некоторым expr
> ```

Существует три случая:
1. ParamType представляет собой указатель или ссылку, но не универсальную ссылку.
2. ParamType является **универсальной ссылкой**.
3. ParamType не является **ни указателем, ни ссылкой**.

> [!example]- Случай 1. ParamType является указателем или ссылкой, но не универсальной ссылкой
1. Если типом expr является ссылка, ссылочная часть игнорируется.
2. Затем выполняется сопоставление типа expr с ParamType для определения T.
```cpp hl:2
template<typename T>
void f(T& param); // param - ссылка

int x = 27; // x - int
const int cx = x; // cx - const int
const int& rx = x; // rx ссылка на x как на const int

f(х);   // Т - int       , тип param - int&
f(cx);  // Т - const int , тип param - coпst int&
f(rx);  // Т - const int , тип param - const int&
```

Во втором и третьем вызовах обратите внимание, что, поскольку сх и rx объявлены как константные значения, `Т` выводится как `const int` , тем самым приводя к типу параметра `const int&`. Это важно для вызывающего кода. Передавая константный объект параметру-ссылке, он ожидает, что объект останется неизменным, т.е. что параметр будет представлять собой ссылку на const. Вот почему передача константного объекта в шаблон, получающий параметр `Т&`, безопасна: константность объекта становится частью выведенного для `Т` типа.

В третьем примере обратите внимание, что несмотря на то, что типом `rx` является ссылка, тип `T` выводится как не ссылочный. Вот почему при выводе типа игнорируется "ссылочность" `rx`.

Если мы изменим тип параметра f с `Т&` на `const Т&`, произойдут небольшие изменения:

```cpp hl:2
template <typename Т>
void f(const Т& param);  // param является ссыпкой на const
int х = 27;              // Как и ранее
const int СХ = х;        // Как и ранее
const int& rx = х;       // Как и ранее
f(х);                    // т - int , тип param - const int&
f(сх);                   // т - int , тип param - const int&
f(rx);                   // т - int , тип param - const int &
```

> [!example]- Случай 2. ParamType является универсальной ссылкой

Универсальные ссылки могут быть как `rvalue`-, так и `lvalue`-ссылкой в зависимости от аргументов или результата функции. 
```cpp
template <class T = String> 
void template_func(T&& string)
{
	...
}
// template_func() принимает любую Xvalue
template_func(string); // String(const String& other)
template_func(std::move(string)); // String(String&& other)
```

Компилятор на основе этого шаблона генерирует 2 функции, одна из которых принимает `lvalue`, другая — `rvalue`, если они будут использоваться.

> Универсальная ссылка обязана быть шаблонным параметром (отсюда такое странное определение шаблона функции в примере) в формате `T&&`. Например, `std::vector<T>&&` уже не универсальная, а `rvalue`-ссылка.

- Если `expr` представляет собой `lvalue`, как `Т`, так и `ParamType` выводятся как `lvаluе` ссылки. Это вдвойне необычно. Во-первых, это единственная ситуация в выводе типа шаблона, когда `Т` выводится как ссылка. Во-вторых, хотя `ParamType` объявлен с использованием синтаксиса `rvаluе`-ссылки, его выводимым типом является lvаluе-ссылка.
- Если `expr` представляет собой `rvalue`, применяются правила из случая 1.
```cpp
template <typename Т>
void f(T&& param);  // param является универсальной ссылкой
int х = 27;         // Как и ранее
const int сх = х;   // Как и ранее
const int& rx х;    // Как и ранее

f(х);   // х - lvalue, так что Т - iпt &,
        // тип pararn также является iпt&
f(сх);  // сх - lvalue , так что Т - const iпt&,
        // тип pararn также является coпst iпt&
f(rx);  // rx - lvalue, так что Т - const iпt& ,
        // тип pararn также является const iпt&
f(27);  // 27 - rvalue , так что Т - int ,
        // следовательно, тип param - iпt&&
```

> [!example]- Случай 3. ParamType не является ни указателем, ни ссылкой

Когда PararnType не является ни указателем, ни ссылкой, мы имеем дело с передачей по значению:
```cpp
template<typeпarne Т>
void f(T param) ; // param передается по значени

```
Это означает, что `param` будет копией переданного функции - совершенно новым объектом. Тот факт, что `param` будет совершенно новым объектом, приводит к правилам, которые регулируют вывод `Т` из `expr`.

1. Как и ранее, если типом `expr` является ссылка, ссылочная часть игнорируется.
2. Если после отбрасывания ссылочной части `expr` является `const`, это также игнорируется
```cpp
int х = 27;         // Как и ранее
const int сх = х;   // Как и ранее
const int& rx = х;  // Как и ранее
f(х);               // Типами и Т, и param являются int
f(сх);              // Типами и Т, и param вновь являются iпt
f(rx);              // Типами и Т, и param опять являются iпt 
```

Обратите внимание, что даже несмотря на то, что `сх` и `rx` представляют константные значения, `param` не является `coпst`. Это имеет смысл: `param` представляет собой объект, который полностью независим от `сх` и `rx`, - это копия `сх` или `rx`.

```cpp
template <typename Т>
void f(Т param);          // param передается по значению
const char* const ptr =   // ptr - константный указатель на
    "Fun with pointers";  // константный объект
f(ptr);                   // Передача arg типа const char* const
```

Здесь `const` справа от звездочки объявляет `ptr` константным: `ptr` не может ни указывать на другое место в памяти, ни быть обнуленным. (`const` слева от звездочки гласит, что `ptr` указывает на то, что (строка символов) является `const`, а следовательно, не может быть изменено.) Когда `ptr` передается в функцию f, биты, составляющие указатель, копируются в `param`. Как таковой сам указатель (`ptr`) будет передан по значению. В соответствии с правилом вывода типа при передаче параметров по значению константность `ptr` будет проигнорирована, а выведенным для `param` типом будет `const char*`, т.е. изменяемый указатель на константную строку символов. Константность того, на что указывает` ptr`, в процессе вывода типа сохраняется, но константность самого `ptr` игнорируется при создании нового указателя `param`.


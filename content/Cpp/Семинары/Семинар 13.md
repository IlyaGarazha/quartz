# Шаблоны

# Шаблоны функций
```cpp
#include <iostream>
#include <string>
using std::cout;

template <typename T>
T maximum(const T& a, const T& b) {
  return a > b ? a : b;
}

int main() {
  maximum<int>(1, 2.0);
  return 0;
}
```

> [!question]- Какая функция вызовется?
> `foo(int x)`, так как следуем принципу "частное предпочтительнее общего"

```cpp
#include <iostream>
using std::cout;

template <typename T>
void foo(T x) {
  cout << 1;
};

void foo(int x) { cout << 2; };

int main() {
  foo(1);
  return 0;
}
```
> [!question]- А какая функция вызовется здесь?
> Здесь действует правило "**лучшее соответствие предпочтительнее частности**". А значит неявное приведение уже менее предпочтительнее. А 1 вариант менее предпочтительнее 2го, так как у него параметры могут иметь разный тип. 
> 1я вызовется при `foo(2.0, 1)`



```cpp
#include <iostream>
using std::cout;

template <typename T, typename U>
void foo(T x, U y) {
  cout << 1;
};

template <typename T>
void foo(T x, T y) {
  cout << 2;
};

void foo(int x, double y) { cout << 3; };

int main() {
  foo(1, 2);
  return 0;
}
```
> [!question]- Что вызовется в следующем примере?
> ОШИБКА! Обе функции подходят, поэтому не могут быть определены одновременно.

```cpp
#include <iostream>
using std::cout;

template <typename T>
void foo(T x) {
  cout << 1;
};

template <typename T>
void foo(T& x) {
  cout << 2;
};

int main() {
  int x = 3;
  int& y = x;
  foo(y);
  return 0;
}
```

# Параметры шаблона по умолчанию
```cpp
template <typename T1, typename T2 = bool, typename T3 = int, typename T4 = char>
T4 sum(T1 a, T2 b) {
return T3(a) + T3(b);
}
```
# Специализация шаблонов
```cpp
#include <iostream>
using std::cout;

template <typename T>
void foo(T x) {
  cout << 1;
};

template <>
void foo(int x) {
  cout << 2;
};

int main() {
  foo(5);
  return 0;
}
```
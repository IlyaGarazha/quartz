Вывод:
1    2     1     4
```cpp
#include <iostream>
using std::cout;
using std::endl;

template <typename T>  // (1.T)
void foo(T) {
  cout << "1" << endl;
}
//    ||
//    ||
//    \/
template <>  // (1.c)
void foo<char *>(char *pc) {
  cout << "3" << endl;
}

template <typename T>  // (2.T*)
void foo(T *) {
  cout << "2" << endl;
}
//    ||
//    ||
//    \/
template <>  // (2. c*)
void foo<char>(char *c) {
  cout << "4" << endl;
}

int main() {
  int i = int();
  foo(i);
  foo(&i);

  char c = char();
  foo(c);
  foo(&c);
}
```
 1. В 31 строчке выводится 1, так как подходит только общий шаблон (1.T), а его специализация не подходит.
2. в 32 строчке вызывается foo(`int *`), что как раз подходит под (2.T*) foo(`T *`), и не подходит его специализация `2.c*` 
3. в 35 строчке снова подходит `1.T` потому, что нет более точной специализации (например, `template<> foo<char>(char))` 
4. В 36 строчке вызывается `2.c*` потому, что из базовых шаблонов `1.T` и `2.T*` при подстановке `foo(char *)` выбирается базовый шаблон `2.T*` и дальше специализируется на `2.c*` 
 Из (2.T*) нельзя специализировать (1.c) так как выйдет `char* *`  
 Если оставить только шаблоны `1.T` и `1.c`, то выведется: `1 1 1 3`. В последнем случае выведется 3, так как `foo(T)` -> `foo(char*)` -> `T=char*` -> `foo<char*>(char*)` 
 Итого: `foo<char>(char *c)` воспринимается как `foo<T>(T *)`, а
  `foo<char*>(char*)` воспринимается как `foo<T>(T)`

### Вопрос 4
Person p = new Person("Ilya", 26);

### Вопрос 6
Задание 6 
 НЕ РАБОТАЕТ, так как в foo.h объявляем шаблонную функцию foo(), при этом её реализация описана в КОМПИЛИРУЕМОМ foo.cpp, но вызываем эту функцию только в main.cpp => в foo.cpp функция не инстанцируется => тело не генерируется (шаблоны не компилируются до инстанцирования) => в линкер не попадет. Тогда при попытке инстанцирования функции foo() в main.cpp произойдет ОШИБКА, так как линкер не нашел тело функции. Исправляем переносом тела функции в некомпилируемый foo.h: (в таком случае реализация функции попадет в компилируемый файл в виде текста и тут же инстанцируется в нем => все ок.)

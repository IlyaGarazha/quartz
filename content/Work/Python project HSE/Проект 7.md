### Фильтрация голоса
1. (*5 баллов*)
	1. Создайте сигнал, в котором с разной амплитудой и фазой будут присутствовать $f(t) = A_1 \sin(\omega_1 t + \varphi_1) + A_2 \cos(\omega_2 t + \varphi_2)+\dots$  , где $\omega_1 =10, \: \omega_2 = 20, \: \omega_3 = 100, \: \omega_4 = 1000, \: \omega_5 = 3000$.
	2. Получите спектр созданного сигнала, используя [быстрое преобразование Фурье](https://proglib.io/p/preobrazovaniya-fure-dlya-obrabotki-signalov-s-pomoshchyu-python-2020-11-03)
	3. Создайте [фильтр](https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.iirnotch.html), подавляющий наибольшую частоту.
	4. Пропустите сигнал через фильтры, чтобы отсечь 2 наибольшие частоты.
	5. Проиллюстрируйте, используя matplotlib:
			а. Изначальную функцию $f(t)$
			б. Спектр функции $f(t)$
			в. Спектры фильтров 2х верхних частот
			г. разницу между фильтрацией, используя спектр и **БИХ-фильтр**, и аналитически отфильтрованной функцией $f_{filt}(t) = f(t) - (A_4 \cos(\omega_4 t + \varphi_4) + A_5 \sin(\omega_5 t + \varphi_5))$
2. (*3 балла*) Запишите свой голос на микрофон (voice.mp3), заранее включив помеху (включив на колонке/ноутбуке [звук](https://youtu.be/TbPh0pmNjo8), с частотой 1000 Гц).
```python
import librosa
import IPython.display as ipd
import matplotlib.pyplot as plt
import librosa.display

audio_path = 'voice.mp3'
x , sr = librosa.load(audio_path)
print(type(x), type(sr))
print(x.shape, sr)

ipd.Audio(audio_path)

plt.figure(figsize=(15, 5))
librosa.display.waveshow(x, sr=sr)
```
Очистите свой сигнал от  частоты  1000Гц.
3. (*2 балла*)
Наложите на симфоническую мелодию без слов (а) свою речь (б).
	1. Из смешанного сигнала (а+б) отфильтруйте мелодию а.